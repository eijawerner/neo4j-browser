// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`MdxSlide renders shakespear 1`] = `
<div>
  <div
    class="sc-gZMcBi iLXFmU"
  >
    <div
      class="sc-VigVT iSOTjO"
    >
      <div
        class="sc-jTzLTM iLaoaZ"
      >
        <div
          class="sc-fjdhpX iXtQeM"
        >
          <h1>
            Network Analysis of Shakespeare's plays
          </h1>
          <p>
            What do you do when a new colleague starts to talk to you about how they would love to experiment with getting a dataset about Romeo & Juliet into a graph? Yes, that's right, you get your graph boots on, and you start looking out for a great dataset that you could play around with. And as usual, one things leads to another (
            <strong>
              it's all connected, 
              <em>
                remember
              </em>
              !
            </strong>
            ), and you end up with this incredible experiment that twists, turns and meanders into something fascinating. That's what happened here too.

            <img
              alt="William Shakespeare"
              src="https://www.biography.com/.image/ar_1:1%2Cc_fill%2Ccs_srgb%2Cg_face%2Cq_auto:good%2Cw_300/MTE1ODA0OTcxNzgzMzkwNzMz/william-shakespeare-194895-1-402.jpg"
            />
          </p>
          <h2>
            Finding a Data source
          </h2>
          <p>
            That was so easy. I very quickly located a 
            <a
              href="https://www.kaggle.com/kingburrito666/shakespeare-plays"
            >
              Dataset on Kaggle
            </a>
             that I thought would be really interesting. It's a comma-separated file, about 110k lines long and 10MB in size, that holds all the lines that Shakespeare wrote for his plays. It's just an amazing dataset - not too complicated, but terribly interesting. 
          </p>
          <p>
            The structure of the file has the following 
            <em>
              File headers
            </em>
            : 
          </p>
          <table>
            <thead>
              <tr>
                <th>
                  Dataline
                </th>
                <th>
                  Play
                </th>
                <th>
                  PlayerLinenumber
                </th>
                <th>
                  ActSceneLine
                </th>
                <th>
                  Player
                </th>
                <th>
                  PlayerLine
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  abc
                </td>
                <td>
                  def
                </td>
                <td>
                  ghi
                </td>
                <td>
                  jkl
                </td>
                <td>
                  mno
                </td>
                <td>
                  pqr
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            Of course you can find the dataset on Kaggle yourself, but I actually quickly imported it into a 
            <a
              href="https://docs.google.com/spreadsheets/d/15c6eUbRMNDrPa0RTuzdrY46OAr2FzKH8tD0KZNoaG8c/edit?usp=sharing"
            >
              google sheet version
            </a>
             that you can access as well. This gsheet is shared and made public on the internet, and can then be 
            <a
              href="https://docs.google.com/spreadsheets/d/15c6eUbRMNDrPa0RTuzdrY46OAr2FzKH8tD0KZNoaG8c/export?format=csv&gid=1470339152"
            >
              downloaded as a csv at any time from this URL
            </a>
            . This URL is what we will use for importing this data into Neo4j.
          </p>
          <p>
            So let's see how we can do that.
          </p>
          <hr />
          <h2>
            Prepare the database
          </h2>
          <p>
            Assuming that you are using one of the latest versions of Neo4j, which supports multiple databases, you should start by creating the database for this exercise:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              :use system;
create or replace database shakespeare;
:use shakespeare;

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=12-sofqpyhCfPihS6XXWmZn3iQwAziXmK"
            />
          </p>
          <p>
            Once that is done, you should also create some indexes on the database, as that will help with the data import and querying later on:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              create index on :Play(name);
create index on :Player(name);
create index on :Scene(name);
create index on :Act(name);
create index on :Line(PlayerLine);
create index on :Line(Dataline);
create index on :Line(Play);
create index on :Line(Act);
create index on :Line(Scene);

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=11wJh5AwDNKa4d7EqmQOEarUyljtoJ2Jq"
            />
          </p>
          <h2>
            Importing the data into Neo4j
          </h2>
          <p>
            Because dhte data is already in .csv format, and available on the web via the google-sheet-link above, importing the data as is into Neo4j is a no-brainer. All you need to do is use the 
            <code>
              LOAD CSV
            </code>
             command. Here's what that looks like:
          </p>
          <h3>
            Loading the lines of all of Shakespeare's plays - with some dataformats as Integers
          </h3>
          <p>
            Note that I needed to do one specific trick, and that is to convert the 
            <code>
              Dataline
            </code>
             and 
            <code>
              PlayerLinenumber
            </code>
             fields to integers, so that we could sort/sequence them later on. Other wise the 
            <code>
              create (l:Line)
            </code>
             statement could have just been folled by 
            <code>
              set l = line
            </code>
             - but we can't do that now.
          </p>
          <p>
            Here's the import statement:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              load csv with headers from "https://docs.google.com/spreadsheets/d/15c6eUbRMNDrPa0RTuzdrY46OAr2FzKH8tD0KZNoaG8c/export?format=csv&gid=1470339152" as line 
    create (l:Line)
    set l.Dataline = toInteger(line.Dataline)
    set l.Play = line.Play
    set l.PlayerLinenumber = toInteger(line.PlayerLinenumber)
    set l.ActSceneLine = line.ActSceneLine
    set l.Player = line.Player
    set l.PlayerLine = line.PlayerLine;

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=12-msYMkNOOF0wbunnp2rknzrJCqjuQ-3"
            />
          </p>
          <p>
            Now that the data is in Neo4j, we can start wrangling it into a much more graphy data structure. Here's how we do that.
          </p>
          <hr />
          <h2>
            Refactoring the data
          </h2>
          <p>
            We already have 
            <code>
              Player
            </code>
             in the 
            <code>
              Line
            </code>
             nodes. So let's extract that first and make them into separate nodes.
          </p>
          <h3>
            Creating the Players of the Lines
          </h3>
          <p>
            We will use a 
            <code>
              MERGE
            </code>
             operation for this to create the node and make sure that it does not get created twice. Next we add the relationship between the player and the line.
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (l:Line)
where l.Player is not null
with l
merge (pl:Player {name: l.Player})
create (pl)-[:ARTICULATES]-&gt;(l);

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=11gcR2olyUyvhW8n6iCIK-g6lDPCvKJw-"
            />
          </p>
          <p>
            Next, we are going to look at 
          </p>
          <ul>
            <li>
              where the Line fits into the 
              <code>
                Scene
              </code>
              , 
            </li>
            <li>
              where the 
              <code>
                Scene
              </code>
               fits into the 
              <code>
                Act
              </code>
              ,
            </li>
            <li>
              and where the 
              <code>
                Act
              </code>
               fits into the Play
            </li>
          </ul>
          <p>
            Here's how we do that.
          </p>
          <h3>
            Extracting the Act and Scene info of the Lines
          </h3>
          <p>
            We have a property on the 
            <code>
              Line
            </code>
             that has the 
            <code>
              ActSceneLine
            </code>
             for every line, separated by a 
            <code>
              .
            </code>
            . Let's first make separate properties of this composite property. Note that we have to account for some 
            <code>
              Line
            </code>
             nodes that don't have an 
            <code>
              ActSceneLine
            </code>
             property, as the original dataset did not have it.
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (l:Line)
where l.ActSceneLine is not null
with l, split(l.ActSceneLine,".") as Array
set l.Act = Array[0]
set l.Scene = Array[1]
set l.Line = Array[2];

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=11sUGJIQ9qlLiV193L3ZHqmKkSTHXD4dg"
            />
          </p>
          <p>
            So now we can proceed with creating a hierarchy (Play&gt;&gt;Act&gt;&gt;Scene&gt;&gt;Line) for every 
            <code>
              Play
            </code>
            . 
          </p>
          <h3>
            Creating the Scene Nodes, linking the lines to the Scenes
          </h3>
          <p>
            Here's how we create the 
            <code>
              Scene
            </code>
             nodes, and link them to the 
            <code>
              Line
            </code>
            s. 
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (l:Line)
where l.ActSceneLine is not null
merge (sc:Scene {name: l.Play+" - Act "+l.Act+" - Scene "+l.Scene})
create (l)-[:PART_OF]-&gt;(sc);

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=11v_s-dX7on9pYr7x3dVMnKycgxegDqm6"
            />
          </p>
          <h3>
            Creating the Act nodes, linking the Scenes to the Acts
          </h3>
          <p>
            Next we can link the 
            <code>
              Scene
            </code>
            s to the 
            <code>
              Act
            </code>
            s:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (l:Line)--&gt;(sc:Scene)
where l.ActSceneLine is not null
merge (a:Act {name: l.Play+" - Act "+l.Act})
merge (sc)-[:PART_OF]-&gt;(a);

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=11kRJwpN-ZPmO16e4YGPG8-TMLUZMq8mY"
            />
          </p>
          <h3>
            Linking the Act to the Plays
          </h3>
          <p>
            And finally we can link the 
            <code>
              Act
            </code>
            s to the 
            <code>
              Play
            </code>
            s:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (l:Line)--&gt;(sc:Scene)--&gt;(a:Act)
where l.ActSceneLine is not null
merge (p:Play {name: l.Play})
merge (a)-[:PART_OF]-&gt;(p);

            </code>
          </pre>
          <p>
            One last thing to clean up, is the fact that there are some 
            <code>
              Line
            </code>
             nodes that don't have an 
            <code>
              ActScenLine
            </code>
             property, and therefore don't have a 
            <code>
              Scene
            </code>
             or an 
            <code>
              Act
            </code>
            , but that do need to be linked to the 
            <code>
              Play
            </code>
            :
          </p>
          <h4>
            Some lines don't have Acts, but are part of the Play!
          </h4>
          <pre>
            <code
              class="language-cypher"
            >
              match (l:Line)
where l.ActSceneLine is null
merge (p:Play {name: l.Play})
merge (l)-[:PART_OF]-&gt;(p);

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=11n0r5BxRU2kegoi-hDsDm7UrLAc7PwNu"
            />
          </p>
          <p>
            Next, we will start making the model a bit more understandable.
          </p>
          <hr />
          <h2>
            Making the model more understandable
          </h2>
          <p>
            Currently, the model basically have a 
            <code>
              Line
            </code>
             connected to every 
            <code>
              Scene
            </code>
             that is in an 
            <code>
              Act
            </code>
             of a 
            <code>
              Play
            </code>
            . That works fine, but it does not give us a lot of clues as to how the play would work. That's why I wanted to create a sequential loop of Lines for every Scene: every Line in the Scene would basically connect to the next one, and then the next one, and then... and so on. Here's how we do that.
          </p>
          <h3>
            Linking the lines in a loop for every scene
          </h3>
          <p>
            We start by linking the lines in a chain.
          </p>
          <h4>
            Link the lines in a chain
          </h4>
          <p>
            We will use the 
            <code>
              Dataline
            </code>
             property of every 
            <code>
              Line
            </code>
             for this.
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (l1:Line), (l2:Line)
where id(l1)&gt;id(l2)
and l1.Play = l2.Play
and l1.Dataline = l2.Dataline + 1
create (l2)-[:FOLLOWED_BY]-&gt;(l1);

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=11haP6To5CjS5ois21aJyqlz17kvqQeSH"
            />
          </p>
          <p>
            Then we proceed by connecting the first and last line to the scene with a specific 
            <code>
              STARTS_WITH
            </code>
             and 
            <code>
              ENDS
            </code>
             relationship.
          </p>
          <h4>
            Connect the chain to the Scene with Start and Ending
          </h4>
          <p>
            We find the first 
            <code>
              Dataline
            </code>
             element and start with that:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (l:Line)--&gt;(s:Scene)
with s, min(l.Dataline) as startline
match (l:Line)
where l.Dataline = startline
create (s)-[:STARTS_WITH]-&gt;(l);

            </code>
          </pre>
          <p>
            And then we find the last 
            <code>
              Dataline
            </code>
             element and end with that:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (l:Line)--&gt;(s:Scene)
with s, max(l.Dataline) as endline
match (l:Line)
where l.Dataline = endline
create (s)&lt;-[:ENDS]-(l);

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=11i3sU9xxE52yXu-VljWifOnZEDDoX_Jw"
            />
          </p>
          <p>
            Now we can also remove the link between 
            <code>
              Line
            </code>
             and 
            <code>
              Scene
            </code>
            :
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (l:Line)-[pao:PART_OF]-(sc:Scene)
delete pao;

            </code>
          </pre>
          <p>
            So how do we use this? We'll took a look at that later when we start querying the data.
          </p>
          <p>
            Let's now explore some more advanced, data science style use cases for this dataset. 
          </p>
          <hr />
          <h2>
            Understanding the importance of different players
          </h2>
          <p>
            One thing that I was trying to figure out, is if the graph could help me understand which characters/players in the graph are more important than others. There's different ways of doing that for sure, and I will just explore two in this article. 
          </p>
          <h3>
            Which Players have most Lines in a Play?
          </h3>
          <p>
            Sounds like a simple enough proxy for 
            <strong>
              <em>
                importance
              </em>
            </strong>
            , right? If a Player has more lines, there's a likelihood that they will have a more important role in the story. So let's go there.
          </p>
          <h4>
            Linking players to plays
          </h4>
          <p>
            First we need to connect the 
            <code>
              Players
            </code>
             to the 
            <code>
              Plays
            </code>
             for this. That's easy enough - as the indirect connection is of course already there. Here's an easy way to achieve what we need:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (pl:Player)--&gt;(l:Line) 
with pl, l
match (p:Play {name:l.Play})
merge (pl)-[pi:PLAYS_IN]-&gt;(p)
on create set pi.nroflines=1
on match set pi.nroflines= pi.nroflines+1;

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=11freUpMju99dXLQk1YnY-pP3Pw1Msx2D"
            />
          </p>
          <p>
            Note that the 
            <code>
              [PLAYS_IN]
            </code>
             relationship now also aggregates the 
            <code>
              nroflines
            </code>
             that a Player has had in a property on the relationship, aka the number of lines that a Player has spoken in a particular play. 
          </p>
          <h3>
            Top 3 players (by number of lines) in every play
          </h3>
          <p>
            Next, I wanted to write a query that would find the top 3 
            <code>
              Players
            </code>
             in every 
            <code>
              Play
            </code>
            . We use a query with a subquery for that: the first part finds all the Plays, and then for every Play I look for the Players and the number of lines that I have stored on the relationship.
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (p:Play)
call {
    with p
    match (pl:Player)-[pi:PLAYS_IN]-&gt;(p)
    return p.name as Play, pl.name as Players, pi.nroflines as NrOfLines
    order by NrOfLines desc
    limit 3
}
return Play, collect(Players) as TopPlayers, collect(NrOfLines) as TopPlayersLines
order by Play;

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=120663GORt08fwwoG4Q7XLDZq08I7hIqu"
            />
          </p>
          <p>
            This already gives us a nice little indication of the importance of the Players, but I would like to suggest a more advanced approach. 
          </p>
          <hr />
          <h2>
            Understanding player importance because of the player-to-player relationships
          </h2>
          <p>
            Here's what I want to do: I would like to infer a new kind of relationship in our graph, called 
            <code>
              RELATED_TO
            </code>
            . This relationship would be introduced between two Player nodes, if the Players had been appearing together in one of 3 levels:
          </p>
          <ol>
            <li>
              appearing together in the Play, ie 
              <strong>
                level 1
              </strong>
            </li>
            <li>
              appearing together in an Act of a Play, ie 
              <strong>
                level 2
              </strong>
            </li>
            <li>
              appearing together in a Scene of an Act of a Play, ie 
              <strong>
                level 3
              </strong>
            </li>
          </ol>
          <p>
            This new relationship will create a mono-partite subgraph of 
            <strong>
              <code>
                (Players)-[:RELATED_TO]-&gt;(OtherPlayers)
              </code>
            </strong>
            , which will be very useful for graph data science work later on. So let's create this.
          </p>
          <h3>
            Level 1: Players in Plays that have played together
          </h3>
          <p>
            Here's the query for that:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (pl1:Player)--&gt;(p:Play)&lt;--(pl2:Player)
where id(pl1)&gt;id(pl2)
merge (pl1)-[r:RELATED_TO]-&gt;(pl2)
set r.level=1;

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=11g41QeeYOCNukFWBsFIjyKTxR46L8RzO"
            />
          </p>
          <h3>
            Level 2: Players in Acts that have played together
          </h3>
          <p>
            This will require a two step process:
          </p>
          <h4>
            Step 1: Link Players to Acts
          </h4>
          <p>
            It's very similar to how we linked Players to Plays:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (pl:Player)--&gt;(l:Line) 
with pl, l
match (a:Act {name:l.Play+" - Act "+l.Act})
merge (pl)-[pi:PLAYS_IN]-&gt;(a)
  on create set pi.nroflines=1
  on match set pi.nroflines= pi.nroflines+1;

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=11cIuPeWABERiF1mVQRcheOlWLP1p0sDp&authuser"
            />
          </p>
          <h4>
            Step 2: Relate the Players if they were in the same Act
          </h4>
          <p>
            Here's how we can create the relationships between players based on being in the same act:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (pl1:Player)--&gt;(a:Act)&lt;--(pl2:Player)
where id(pl1)&gt;id(pl2)
merge (pl1)-[r:RELATED_TO]-&gt;(pl2)
set r.level=2;

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=11eyhqXIofPXihC4KP7L6m6nkrD5NO43F"
            />
          </p>
          <h3>
            Level 3: Players in Scenes that have played together
          </h3>
          <p>
            Again, we need two steps:
          </p>
          <h4>
            Step 1: Link Players to Scenes
          </h4>
          <p>
            We go about this in a very similar way:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (pl:Player)--&gt;(l:Line) 
with pl, l
match (s:Scene {name:l.Play+" - Act "+l.Act+" - Scene "+l.Scene})
merge (pl)-[pi:PLAYS_IN]-&gt;(s)
  on create set pi.nroflines=1
  on match set pi.nroflines= pi.nroflines+1;

            </code>
          </pre>
          <h4>
            Step 2: Relate the Players if they were in the same Scene
          </h4>
          <p>
            Again, very similar to the above:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (pl1:Player)--&gt;(s:Scene)&lt;--(pl2:Player)
where id(pl1)&gt;id(pl2)
merge (pl1)-[r:RELATED_TO]-&gt;(pl2)
set r.level=3;

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=11aCpwQc6-8zigQkzJHuA-7spHnJ5ll0M"
            />
          </p>
          <p>
            That sets us up nicely for a couple of interesting explorations. Let's get into that.
          </p>
          <hr />
          <h2>
            Some queries and visualisations
          </h2>
          <p>
            Of course there are some great ways to now start working with the data. First we will do some simple queries in the Neo4j Browser. 
          </p>
          <h3>
            Look at an entire scene
          </h3>
          <p>
            Let's look at this in two ways:
          </p>
          <h4>
            In the Neo4j Browser
          </h4>
          <p>
            Here's a fairly simple Cypher query, that would look at one entire scene. We are taking a scene from 
            <strong>
              Romeo and Juliet
            </strong>
             in this case. 
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match entirescene = (p:Play)--(a:Act)--(s:Scene)-[:STARTS_WITH]-&gt;(firstline:Line)-[:FOLLOWED_BY*]-(lastline:Line)-[:ENDS]-(s)
  where p.name contains "Romeo"
  with entirescene, nodes(entirescene) as nodes
  limit 1
  unwind nodes as node
  match (node)-[r]-(conn)
  return entirescene, node, r, conn;

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=1217AfNw-Pa4jR0wvl8GSk8RgBa19xsKO"
            />
          </p>
          <p>
            Obviously that's not the greatest visualisation. So let's improve that.
          </p>
          <h4>
            In Neo4j 
            <a
              href="https://neo4j.com/product/bloom/"
            >
              Bloom
            </a>
          </h4>
          <p>
            In Neo4j 
            <a
              href="https://neo4j.com/product/bloom/"
            >
              Bloom
            </a>
            , we can actually customize this query above, by making it into a search phrase. Essentially we parametrise the 
            <code>
              Play
            </code>
             name in the search phrase (look for the 
            <code>
              $param
            </code>
             in the screenshot below):
          </p>
          <p>
            <img
              src="https://drive.google.com/uc?id=11YrwA5v-hNcQbs9FgJavDMfUV5TlLZUx"
            />
          </p>
          <p>
            The result then looks like this:

            <img
              src="https://drive.google.com/uc?id=11ZvaRuV_whO7iTbX5U5lEqTmw-Xz7Js5"
            />
            
This is clearly a lot easier to look at.
          </p>
          <p>
            Let's look at another query pattern.
          </p>
          <h3>
            Show network of players and their relatedness
          </h3>
          <p>
            Based on the 
            <code>
              [RELATED_TO]
            </code>
             relationship that we created, we can now look at the players and their "network" of interactions during the play. 
          </p>
          <h4>
            In the Neo4j Browser
          </h4>
          <p>
            Here's a simple view of the network of Player relations based on the relations above, for the 
            <code>
              Romeo and Juliet
            </code>
             Play. If we run this query:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (pl1:Player)--&gt;(l:Line)--&gt;(:Scene)--&gt;(a:Act)--&gt;(p:Play {name: "Romeo and Juliet"})
with pl1
match playerrelations = (pl1)-[:RELATED_TO]-(pl2:Player)
return playerrelations;

            </code>
          </pre>
          <p>
            The result very quickly becomes a bit of a hairball:

            <img
              src="https://drive.google.com/uc?id=124mtjiebKgw249WHdRJxphToQ67aG6MU"
            />
          </p>
          <p>
            But luckily, we can also parametrise this as a search phrase in 
            <a
              href="https://neo4j.com/product/bloom/"
            >
              Bloom
            </a>
            .
          </p>
          <h4>
            In Neo4j 
            <a
              href="https://neo4j.com/product/bloom/"
            >
              Bloom
            </a>
          </h4>
          <p>
            Here's what the phrase looks like:

            <img
              src="https://drive.google.com/uc?id=11axHhu_jqe7fvpHp_w1azOh15OfoHXOT"
            />
            
And applying that becomes a much more interesting picture:

            <img
              src="https://drive.google.com/uc?id=11X2zNZxmnH_KhjsstriR7K9bDfO07Fv4"
            />
            
Which allows me to very quickly zoom into the more improtant "Player nodes":

            <img
              src="https://drive.google.com/uc?id=11XdxixB7t9hZnrNt_tE8-IQem2lHBV1t"
            />
          </p>
          <p>
            <strong>
              The point here is of course that, without reading a single line of the text, the graph is telling me which Players are likely to be more important than others.
            </strong>
             I just love that. I think this is why we can also apply this to so many other domains. 
            <em>
              The graph structure is immediately giving us insights.
            </em>
          </p>
          <p>
            Now let's see how we can enhance this even further, by applying graph algorithms from the 
            <a
              href="https://neo4j.com/product/graph-data-science-library/"
            >
              Graph Data Science Library
            </a>
             to this structure. Should be fun!
          </p>
          <hr />
          <h2>
            Running Graph Data Science on the network
          </h2>
          <p>
            Now that we have that 
            <code>
              RELATED_TO
            </code>
             relationship, we can actually do some very interesting graph data science work, as this is now a mono-partite subgraph, containing only 
            <code>
              Player
            </code>
             nodes and 
            <code>
              RELATED_TO
            </code>
             relationships. 
          </p>
          <p>
            I am a big fan of using 
            <a
              href="https://neo4j.com/developer/graph-data-science/neuler-no-code-graph-algorithms/"
            >
              Neuler
            </a>
             for doing some of this simple 
            <a
              href="https://neo4j.com/product/graph-data-science-library/"
            >
              graph data science
            </a>
             work. It's just a few clicks away, and it generates the code for the most interesting algorithms. I have picked two in this case: 
            <a
              href="https://en.wikipedia.org/wiki/PageRank"
            >
              Pagerank
            </a>
             and 
            <a
              href="https://en.wikipedia.org/wiki/Betweenness_centrality"
            >
              Betweenness
            </a>
            , both of them different variations of Centrality calculation algorithms.
          </p>
          <h3>
            Calculating 
            <a
              href="https://en.wikipedia.org/wiki/PageRank"
            >
              Pagerank
            </a>
             centrality
          </h3>
          <p>
            Here's how we do that:
          </p>
          <h4>
            <a
              href="https://en.wikipedia.org/wiki/PageRank"
            >
              Pagerank
            </a>
             centrality
          </h4>
          <p>
            With a few clicks we can actually configure the algorithm on Neuler.

            <img
              src="https://drive.google.com/uc?id=11VEUvO--TtE6qevg3j-58Ak_S4aCOcw4"
            />
          </p>
          <p>
            The code that is actually being run for this looks like this:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              :param limit =&gt; ( 42);
:param config =&gt; ({
  nodeProjection: 'Player',
  relationshipProjection: {
    relType: {
      type: 'RELATED_TO',
      orientation: 'UNDIRECTED',
      properties: {
        level: {
          property: 'level',
          defaultValue: 1
        }
      }
    }
  },
  relationshipWeightProperty: 'level',
  dampingFactor: 0.85,
  maxIterations: 20,
  writeProperty: 'pagerank'
});
:param communityNodeLimit =&gt; ( 10);
CALL gds.pageRank.write($config);

            </code>
          </pre>
          <p>
            Once that's done, we can run a very simple Cypher query to show the 
            <a
              href="https://en.wikipedia.org/wiki/PageRank"
            >
              Pagerank
            </a>
             property of all the Players:
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (pl:Player)--&gt;(l:Line)--&gt;(:Scene)--&gt;(a:Act)--&gt;(p:Play {name: "Romeo and Juliet"})
return distinct pl.name, pl.pagerank, pl.betweenness
order by pl.pagerank desc
limit 10;

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=125r-AmHfqA9cMwGpZSbr0W-ZbTLXl-yO"
            />
          </p>
          <p>
            Then we can also run another interesting centrality metric. Here's how we do that:
          </p>
          <h3>
            Calculating 
            <a
              href="https://en.wikipedia.org/wiki/Betweenness_centrality"
            >
              Betweenness
            </a>
             centrality
          </h3>
          <p>
            With a few clicks we can actually configure the algorithm on Neuler. 
          </p>
          <p>
            <img
              src="https://drive.google.com/uc?id=11WoB95uG1VnWI_BmKZfad431uOho3HcL"
            />
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              :param limit =&gt; ( 42);
:param config =&gt; ({
  nodeProjection: 'Player',
  relationshipProjection: {
    relType: {
      type: 'RELATED_TO',
      orientation: 'UNDIRECTED',
      properties: {}
    }
  },
  writeProperty: 'betweenness'
});
:param communityNodeLimit =&gt; ( 10);
CALL gds.betweenness.write($config);

            </code>
          </pre>
          <p>
            Once that's done, we can run a very simple Cypher query to show the 
            <a
              href="https://en.wikipedia.org/wiki/Betweenness_centrality"
            >
              Betweenness
            </a>
             of players
          </p>
          <pre>
            <code
              class="language-cypher"
            >
              match (pl:Player)--&gt;(l:Line)--&gt;(:Scene)--&gt;(a:Act)--&gt;(p:Play {name: "Romeo and Juliet"})
return distinct pl.name, pl.pagerank, pl.betweenness
order by pl.betweenness desc
limit 10;

            </code>
          </pre>
          <p>
            <img
              src="https://drive.google.com/uc?id=128JYgwzGa-Ae11VMnd0vYOWHmP1razNc"
            />
          </p>
          <p>
            No doubt there are tons of additional things we could do with this dataset, but here's where my exercise will end. I am hoping that this was a useful story for you - it definitely was for me.
          </p>
          <p>
            All the best
          </p>
          <p>
            Rik Van Bruggen 
          </p>
          <ul>
            <li>
              <a
                href="https://twitter.com/rvanbruggen"
              >
                Twitter
              </a>
               
            </li>
            <li>
              <a
                href="http://blog.bruggen.com/"
              >
                Blog
              </a>
            </li>
            <li>
              <a
                href="https://www.linkedin.com/in/rikvanbruggen/"
              >
                LinkedIn
              </a>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>
`;
